COPY
=====

在文件和表之间复制数据。

---

语法
--------

```sql
COPY <table_name> [(<column_name> [, ...])] 
     FROM {'<file_name>' | STDIN}
     [ [ WITH ] ( <option> [, ...] ) ]

COPY { <table_name> [(<column_name> [, ...])] | (<query>)} 
     TO STDOUT
     [ [ WITH ] ( <option> [, ...] ) ]

其中 <option> 可以是以下任何一项:

FORMAT <format_name>
OIDS [ <boolean> ]
FREEZE [ <boolean> ]
DELIMITER '<delimiter_character>'
NULL '<null string>'
HEADER [ <boolean> ]
QUOTE '<quote_character>'
ESCAPE '<escape_character>'
FORCE_QUOTE { ( <column_name> [, ...] ) | * }
FORCE_NOT_NULL ( <column_name> [, ...] ) 
FORCE_NULL ( <column_name> [, ...] )
ENCODING '<encoding_name>'       
FILL MISSING FIELDS
LOG ERRORS [ SEGMENT REJECT LIMIT <count> [ ROWS | PERCENT ] ]
```


---

描述
----------


`COPY` 在 Relyt 表和标准文件系统文件之间移动数据。`COPY ... TO` 将表的内容复制到文件，而 `COPY ... FROM` 将文件的数据复制到表（追加到表中已有的数据）。`COPY ... TO` 还可以复制 `SELECT` 查询的结果。


如果指定了列，`COPY` 将只复制指定列中的数据到文件或从文件。如果表中包含未被指定的列，`COPY ... FROM` 将为这些列插入默认值。


**输出**

成功完成后，`COPY` 命令返回一个命令标签，其中 *`<count>`* 是复制的行数：

```sql
COPY <count>
```

如果在单行错误隔离模式下运行 `COPY ... FROM` 命令，如果有任何行因格式错误而未加载，将返回以下通知消息，其中 *`<count>`* 为被拒绝的行数：

```sql
NOTICE: Rejected <count> badly formatted rows.
```

---

参数
----------

- *`<table_name>`*

    要复制的表的名称，支持使用 Schema 名称进行限定。

- *`<column_name>`*

    要复制的列的可选列表。如果没有指定该参数，将复制表的所有列。
    
    在文本格式下复制时，默认情况下，`bytea` 类型的列中的一行数据可以达到 256 MB。

- *`<query>`*

    要复制的 `SELECT` 或 `VALUES` 命令的结果。注意，查询需要用括号括起来。

- *`<file_name>`*

    输入或输出文件的路径名。目前，只支持 S3 文件。

- **`STDIN`**

    指定输入来自客户端应用。

- **`STDOUT`**

    指定输出到客户端应用。

- *`<boolean>`*

    指定所选选项应该打开还是关闭。打开选项，设置为 `TRUE`、`ON` 或 `1`；关闭选项，设置为 `FALSE`、`OFF` 或 `0`。如不填写该值，则默认为 `TRUE`。

- **`FORMAT`**

    选择要读取或写入的数据格式：`text`、`csv` 或 `binary`。默认为 `text`。

- **`OIDS`** 

    指定复制每行的 OID。如果对没有 OID 的表或在复制查询的情况下指定 OIDS，将引发错误。

- **`FREEZE`**

    请求在复制过程中冻结数据的行，效果等同于执行了 `VACUUM FREEZE` 之后的操作。`FREEZE` 是用于初始数据加载的性能选项。只有在加载的表在当前子事务中被创建或截断、没有打开的游标，并且此事务没有持有任何旧的快照时，行才会被冻结。
    
    注意，数据一旦加载成功即对所有其他会话可见。这违背 MVCC 可见性的一般原则。设置该选项时，用户需要关注此设置可能带来的潜在问题。

- **`DELIMITER`**

     指定分隔符，用于分割文件中各行里的列。默认情况下，`text` 为制表符，`CSV` 为英文逗号。分隔符必须是单个一字节字符。`binary` 不支持该选项。

- **`NULL`**

     指定表示空值的字符串。默认情况下，`text` 为 `\N`（反斜杠 N），`CSV` 为未引用的空字符串。在 `text`，你也可以将空值设置为空字符串，从而不用对空值和空字符串进行区分。`binary` 文件不支持该选项。

     :::note
     在使用 `COPY ... FROM` 时，任何与此字符串匹配的数据项都将被存储为 null 值，因此你应确保使用与 `COPY ... TO` 中使用的相同的字符串。
     :::

- **`HEADER`**

     指定文件的标题行，标题行包含文件中每个列的名称。在输出时，第一行包含来自表的列名称，在输入时，忽略第一行。只有 `CSV` 支持该选项。

- **`QUOTE`**

     指定当数据值被引用时使用的引用字符，默认为双引号。引用字符必须是单个一字节字符。只有 `CSV` 支持该选项。

- **`ESCAPE`**

     指定应出现在与 `QUOTE` 值匹配的数据字符之前的字符。默认与 `QUOTE` 值相同（因此，如果引用字符出现在数据中，引用字符需要出现两次）。这必须是单个一字节字符。只有 `CSV` 支持该选项。

- **`FORCE_QUOTE`**

     强制对每个指定列中的所有非 `NULL` 值进行引用。`NULL` 输出永远不会被引用。如果 * 指定，非 `NULL` 值将在所有列中被引用。此选项只允许在 `COPY TO` 中使用，并且文件格式必须是 `CSV`。

- **`FORCE_NOT_NULL`**

     不要将指定列的值与空字符串进行匹配。在默认情况下，空字符串为空的情况下，这意味着即使没有引用，空值也将被读取为零长度字符串，而不是空。此选项只允许在 `COPY FROM` 中使用，并且文件格式必须是 `CSV`。

- **`FORCE_NULL`**

     即使已经引用，也要将指定列的值与空字符串进行匹配，如果找到匹配项，将值设置为 `NULL`。在默认情况下，空字符串为空，这将一个引用的空字符串转换为 `NULL`。此选项只允许在 `COPY FROM` 中使用，并且文件格式必须是 `CSV`。

- **`ENCODING`**

     指定文件以 *`<encoding_name>`* 进行编码。如果省略此选项，将使用当前的客户端编码。更多信息，参考 [使用注意事项](#使用注意事项)。

- **`NEWLINE`**

     指定你的数据文件中使用的换行符 - `LF`（换行，0x0A），`CR`（回车，0x0D），或 `CRLF`（回车加换行，0x0D 0x0A）。

- **`CSV`**

     选择 CSV 模式。

- **`FILL MISSING FIELDS`**

     在 `COPY ... FROM` 更多的 `TEXT` 和 `CSV` 中，指定 `FILL MISSING FIELDS` 将在数据行的行尾缺少数据字段时，将缺失的尾随字段值设置为 `NULL`（而不是报告错误）。空行、具有 `NOT NULL` 约束的字段和行上的尾随分隔符仍将报告错误。


---

 
文件格式
--------

`COPY` 支持的文件格式包括：


 

### 文本格式

使用 `text` 格式时，读取或写入的数据是一个文本文件，文件中行和表中的行一一对应。行中的列由 *`delimiter_character`*（默认为制表符）分隔。列值本身是由每个属性的数据类型的输出函数生成的字符串，或者是可以接收的输入函数。指定的空字符串用于替代空的列。如果输入文件的任何行包含的列数多于或少于预期的列数，`COPY ... FROM` 会引发错误。如果指定了 `OIDS`，则 `OID` 作为第一列读取或写入，位于用户数据列之前。

数据文件有两个保留字符，对 `COPY` 有特殊含义：

- 指定的分隔符字符（默认为制表符），用于在数据文件中分隔字段。
  
- UNIX 风格的换行符（`\n` 或 `0x0a`），用于在数据文件中指定新行。强烈建议生成 `COPY` 数据的应用将数据换行符转换为 UNIX 风格的换行符，而不是 Microsoft Windows 风格的回车换行符（`\r\n` 或 `0x0a 0x0d`）。

如果数据包含这两种字符中的任何一种，必须对该字符进行转义，这样 `COPY` 才会将其视为数据，而不是字段分隔符或新行。

默认情况下，文本格式文件的转义字符是反斜杠（\），`csv` 格式文件的转义字符是双引号（"）。如果你想使用不同的转义字符，可以使用 `ESCAPE AS` 子句。确保选择一个不在你的数据文件中作为实际数据值使用的转义字符。你也可以使用 `ESCAPE 'OFF'` 在文本格式文件中取消转义。

例如，假设你有一个包含三列的表，你想使用 `COPY` 加载以下三个字段。

- percentage sign = %
- vertical bar = |
- backslash = \

你指定的 *`<delimiter_character>`* 是 `|`（竖线），你指定的转义字符是 `*`（星号）。你的数据文件中的格式化行将如下所示：

```sql
percentage sign = % | vertical bar = *| | backslash = \
```

注意数据中的竖线是如何使用星号字符（*）转义的。此外，Relyt 不需要转义反斜杠，因为 Relyt 使用了另一个转义字符。

以下字符在作为列值的一部分出现时必须以转义字符开头： 转义字符本身、换行符、回车符和当前的分隔符字符。你可以使用 `ESCAPE AS` 子句指定不同的转义字符。


 

### CSV 格式

此格式选项用于导入和导出许多其他程序（如电子表格）所使用的逗号分隔值（CSV）文件格式。与 Relyt 标准文本格式使用的转义规则不同，它生成并识别通用的 CSV 转义机制。

每条记录中的值由 `DELIMITER` 字符分隔。如果值包含分隔符字符、`QUOTE` 字符、`ESCAPE` 字符（默认为双引号）、`NULL` 字符串、回车符或换行符，那么整个值会被 `QUOTE` 字符前缀和后缀。你还可以使用 `FORCE_QUOTE` 在输出特定列的非 `NULL` 值时强制使用引号。

CSV 格式没有标准的方式来区分 `NULL` 值和空字符串。Relyt 的 `COPY` 通过引用来处理这个问题。`NULL` 作为 `NULL` 参数字符串输出，并且不带引号，而与 `NULL` 字符串匹配的非 `NULL` 值带有引号。例如，使用默认设置，`NULL` 作为未引用的空字符串写入，而空字符串数据值带有双引号（""）。读取值遵循类似的规则。你可以使用 `FORCE_NOT_NULL` 防止对特定列进行 `NULL` 输入比较。你还可以使用 `FORCE_NULL` 将带引号的空字符串数据值转换为 `NULL`。

因为反斜杠在 `CSV` 格式中不是特殊字符，所以 `\.`, 即数据结束标记，也可能作为数据值出现。为避免任何误解，一个 `\.` 数据值作为一行上的单独条目出现时，在输出时会自动引用，在输入时，如果被引用，不会被解释为数据结束标记。如果你正在加载另一个应用创建的文件，该文件有一个未引用的列，可能有一个值为 `\.`, 你可能需要在输入文件中引用该值。

:::note
在 `CSV` 格式中，所有字符都是重要的。被引号包围的值前后如果有空白字符，或者除了 `DELIMITER` 之外的任何字符，都会包含这些字符。这可能会导致错误，如果你从一个将 CSV 行填充到固定宽度的空白字符的系统导入数据。如果出现这种情况，你可能需要预处理 CSV 文件，删除尾部的空白字符，然后将数据导入到 Relyt 中。
:::

`CSV` 格式将会识别并生成带有嵌入式回车和换行符的引用值的 CSV 文件。因此，这些文件并不像文本格式文件那样严格地每行对应一个表行。

:::note
许多程序生成的 CSV 文件很奇怪，有时甚至是反常的，所以文件格式更像是一个约定，而不是一个标准。因此，你可能会遇到一些无法使用此机制导入的文件，而 `COPY` 可能会生成其他程序无法处理的文件。
:::

 

### 二进制格式

`binary` 格式选项会导致所有数据以二进制格式存储/读取，而不是文本。它比文本和 `CSV` 格式处理起来速度会更快一些，但是二进制格式文件在机器架构和 Relyt 版本之间的可移植性较差。另外，二进制格式非常依赖于数据类型。例如从 `smallint` 列输出二进制数据并将其读入 `integer` 列会失败，但是在文本格式中是可以成功的。

二进制文件格式由文件头、包含行数据的元组（可选）和文件尾组成。头和数据以网络字节序存储。

- **文件头** —— 文件头由 15 字节的固定字段组成，后面跟着一个可变长度的头扩展区。固定字段包括：

     - **签名** —— 11 字节序列 PGCOPY\n\377\r\n\0 —— 注意，值为 0 的字节是签名的必需部分。 
     
          签名的设计是为了方便识别被非 8 位干净传输弄乱的文件。这个签名会被行尾转换过滤器、丢弃的值为 0 的字节、丢弃的高阶位 (bit) 或奇偶校验改变。

     - **标志字段** —— 32 位整数位掩码，用于标记文件格式的重要方面。位从 0（LSB）编号到 31（MSB）。注意，该字段以网络字节序（最高有效字节优先）存储，如同文件格式使用的所有整数字段一样。16-31 位保留用于表示关键的文件格式问题；如果读取器发现此范围中设置了意外的位，应取消。0-15 位保留用于表示向后兼容的格式问题；读取器应简单地忽略此范围中设置的任何意外位。目前只定义了一个标志，其余的必须为零（位 16：如果数据有 OIDs，则为 1，否则为 0）。

     - **头扩展区长度** —— 32 位整数，头剩余部分的长度（字节数），不包括自身。目前，这是零，第一个元组紧随其后。未来对格式的更改可能允许头中出现额外的数据。读取器应静默跳过它不知道如何处理的任何头扩展数据。头扩展区预计包含一系列自我标识的块。标志字段不打算告诉读取器扩展区中有什么。头扩展内容的具体设计留给以后的版本。

- **元组** —— 每个元组以包含元组中字段数的 16 位整数开始。 （目前，一个表中的所有元组都会有相同的计数，但这可能不总是这样。）然后，对元组中的每个字段重复一个 32 位长度字和该字长的字段数据。 （长度字不包括自身，可以为零。）作为一个特例，-1 表示 NULL 字段值。在 NULL 情况下，不跟随任何值字节。

     字段之间没有对齐填充或其他额外数据。

     目前，二进制格式文件中的所有数据值都被认为是二进制格式（代码为一）。预计未来的扩展可能会添加一个允许指定每列格式代码的头字段。

     如果文件中包含了 OID，那么 OID 字段会紧接在字段计数之后出现。这是一个普通的字段，唯一的区别是它并未包含在字段计数中。特别地，它具有一个长度字，这使得处理 4 字节和 8 字节的 OID 不会显得过于复杂，同时在有需求时，也允许 OID 呈现为 null。

- **文件尾** —— 文件尾由包含 `-1` 的 16 位整数字组成，易于和元组的字段计数字进行区分。如果字段计数字既不是 `-1`，也不是预期的列数，则读取器会报错。这提供了一个额外的检查，防止了数据同步失效的情况。



---

使用注意事项
--------

`COPY` 只能用于表，不能用于外部表或视图。但是，你可以用 `COPY (SELECT * FROM viewname) TO ...`。

`COPY` 只处理指定的表；它不会将数据复制到子表或从子表复制数据。因此，例如 `COPY <table> TO` 显示的数据与 `SELECT * FROM ONLY table` 的数据相同。但是，可以使用 `COPY (SELECT * FROM table) TO ...` 来转储继承层次结构中的所有数据。


`BINARY` 关键字会让所有数据以 `binary` 格式存储/读取，而不是 `text` 格式。它比正常的文本模式稍快一些，但二进制格式文件在机器架构和 Relyt 版本之间的可移植性较差。此外，如果数据以二进制格式进行存储/读取，你无法在单行错误隔离模式下运行 `COPY FROM`。

你必须对 `COPY TO` 读取其值的表具有 `SELECT` 权限，对 `COPY FROM` 插入值的表具有 `INSERT` 权限。对命令中列出的列具有列权限就足够了。

在 `COPY` 命令中命名的文件直接由数据库服务器读取或写入，而不是由客户端应用。因此，它们必须位于或者可以访问 Relyt 协调器主机机器，而不是客户端。它们必须可以被 Relyt 系统用户（服务器以用户 ID 运行）访问和读取或写入，而不是客户端。只有数据库超级用户被允许在 COPY 中命名文件，因为这允许读取或写入服务器有权限访问的任何文件。

`COPY FROM` 将调用目标表上的任何触发器和检查约束。但是，它不会调用重写规则。注意在这个版本中，对于单行错误隔离模式，约束的违反不会被评估。

`COPY` 输入和输出受 `DateStyle` 影响。为确保可以移植到其他可能使用非默认 `DateStyle` 设置的 Relyt 安装，应在使用 `COPY TO` 之前将 `DateStyle` 设置为 ISO。避免使用 `IntervalStyle` 设置为 `sql_standard` 来转储数据，因为负间隔值可能会被具有不同 `IntervalStyle` 设置的服务器误解。

根据 `ENCODING` 选项或当前客户端编码解释输入数据，以 `ENCODING` 或当前客户端编码编码输出数据，即使数据没有通过客户端，而是由服务器直接从文件读取或写入。

在以文本模式从文件复制 XML 数据时，服务器配置参数 `xmloption` 影响复制的 XML 数据的验证。如果值为 `content`（默认），则将 XML 数据验证为 XML 内容片段。如果参数值为 `document`，则将 XML 数据验证为 XML 文档。如果 XML 数据无效，`COPY` 返回错误。

默认情况下，`COPY` 在第一个错误时停止操作。这不应导致 `COPY TO` 出现问题，但是目标表已经接收了 `COPY FROM` 的早期行。这些行不会被看到或访问，但它们仍然占用磁盘空间。如果故障发生在大型 `COPY FROM` 操作的深入过程中，这可能会造成大量的浪费磁盘空间。你可能希望调用 `VACUUM` 来回收浪费的空间。另一个选择是使用单行错误隔离模式过滤掉错误行，同时仍然加载好的行。

`FORCE_NULL` 和 `FORCE_NOT_NULL` 可以同时在同一列上使用。这会导致将带引号的空字符串转换为 null 值，将未引用的空字符串转换为空字符串。

当数仓用户运行 COPY 命令时，命令可以由资源队列控制。资源队列必须配置 `ACTIVE_STATEMENTS` 参数，该参数指定了分配给该队列的角色可以运行的查询的最大限制。Relyt 不会对 `COPY` 命令应用成本值或内存值，只有成本或内存限制的资源队列不会影响 `COPY` 命令的运行。


---


示例
--------

使用竖线（|）作为字段分隔符，将表复制到客户端：

```sql
COPY country TO STDOUT (DELIMITER '|');
```

从 S3 文件中复制数据到 `country` 表：

```sql
COPY nation FROM 's3://s3.ap-southeast-1.amazonaws.com/******/tpch/100m/nation.tbl' 
    ACCESS_KEY_ID '******'
    SECRET_ACCESS_KEY '******'
    CSV DELIMITER '|'
    HEADER;
```



---

SQL 标准兼容性
-------------

SQL 标准中没有 `COPY` 语句。
