PREPARE
=====

创建预处理语句。


---

语法
--------

```sql
PREPARE <name> [ (<data_type> [, ...] ) ] AS <statement>
```

---

描述
--------

预处理语句是一个服务器端对象，可以用来优化性能。当你运行 `PREPARE` 语句来准备一个语句时，该语句被解析，分析，然后重写。随后发出 `EXECUTE` 命令时，预处理语句被规划并运行。这种劳动分工避免了重复的解析分析工作，同时允许执行计划依赖于提供的具体参数值。

预处理语句可以接受参数，这些值在运行语句时被替换到语句中。在创建预处理语句时，按位置引用参数，使用 `$1`，`$2` 等。在运行语句时，在 [EXECUTE](execute.md) 语句中指定这些参数的实际值。

预处理语句仅在当前数据库会话的持续时间内有效。当会话结束时，预处理语句被遗忘，所以在再次使用之前必须重新创建。这也意味着一个单一的预处理语句不能被多个同时的数据库客户端使用。然而，每个客户端都可以创建他们自己的预处理语句来使用。你可以使用 [DEALLOCATE](deallocate.md) 命令手动清理预处理语句。

当一个单一的会话被用来运行大量类似的语句时，预处理语句具有最大的性能优势。如果语句的规划或重写很复杂，例如，如果查询涉及多表联接或需要应用多个规则，那么性能差异将会特别明显。如果语句相对简单地规划和重写但运行相对昂贵，那么预处理语句的性能优势将不太明显。


---

参数
----------

- *`<name>`*

    预处理语句的名称。它在单个会话中必须是唯一的，随后用于运行或释放预处理语句。

- *`<data_type>`*

    在预处理语句中使用的参数的数据类型。如果参数的数据类型未指定或指定为 `unknown`，那么它将从参数首次被引用的上下文中推断出来。在预处理语句本身中引用参数，使用 `$1`，`$2` 等。

- *`<statement>`*

    任何 `SELECT`，`INSERT`，`UPDATE`，`DELETE` 或 `VALUES` 语句。


---


使用注意事项
--------

预处理语句可以运行一个通用计划或一个自定义计划。通用计划在所有执行中是相同的，而自定义计划使用在那个调用中给出的参数值为特定执行生成。使用通用计划可以避免规划开销，但在某些情况下，自定义计划将更有效率，因为 Planner 可以利用参数值的知识。如果预处理语句没有参数，那么总是使用通用计划。

默认情况下，服务器会自动选择是否为有参数的预处理语句使用通用计划或自定义计划。当前的规则是，前 5 次执行都使用自定义计划，然后 Relyt 计算这些计划的平均预计成本。然后创建一个通用计划，并将其预计成本与平均自定义计划成本进行比较。如果通用计划的成本并不比平均自定义计划的成本高很多，以至于使得重复规划看起来更优，则后续执行使用通用计划。

你可以通过设置 `plan_cache_mode` 为 `force_generic_plan` 或 `force_custom_plan` 来覆盖这个启发式规则，强制服务器使用通用计划或自定义计划。这个设置主要是在通用计划的成本估计因某种原因严重偏离，允许它被选择，即使它的实际成本远远超过自定义计划的成本。


要查看 Relyt 为预处理语句使用的查询计划，使用 [EXPLAIN](explain.md)，例如：

```sql
EXPLAIN EXECUTE <name> (<parameter_values>);
```

如果使用的是通用计划，它将包含参数符号 `$n`，而自定义计划将在其中插入提供的参数值。

有关查询规划和 Relyt 为此目的收集的统计信息的更多信息，请参见 [ANALYZE](analyze.md)。

尽管预处理语句的主要目的是避免重复解析和规划语句，但 Relyt 在使用预处理语句之前，如果语句中使用的数据库对象自上次使用预处理语句以来经过了定义（DDL）更改，Relyt 将强制重新分析和重新规划语句。此外，如果 `search_path` 的值从一次使用到下一次使用发生了变化，那么将使用新的 `search_path` 重新解析语句。这些规则使得使用预处理语句在语义上几乎等同于重复提交相同的查询文本，但如果没有对象定义的更改，特别是如果最优计划在使用中保持不变，则具有性能优势。一个语义等价性不完美的例子是，如果语句引用了一个未经限定的名称的表，然后在 `search_path` 中更早出现的 Schema 中创建了一个同名的新表，那么由于在语句中使用的对象没有改变，不会自动重新解析。然而，如果某些其他变化强制进行重新解析，那么在后续使用中将引用新表。

你可以通过查询 `pg_prepared_statements` 系统视图来查看会话中所有可用的预处理语句。


---


示例
--------

创建一个 `INSERT` 语句的预处理语句，然后运行它：

```sql
PREPARE pendings (integer, bool, numeric) AS 
INSERT INTO my_favorites VALUES ($1, $2, $3);
EXECUTE pendings(1, 'true', 'volleyball');
```

创建一个 `SELECT` 语句的预处理语句，然后运行它。注意，第二个参数的数据类型没有指定，所以它是从 `$2` 被使用的上下文中推断出来的：

```sql
PREPARE usrrptplan (int) AS
SELECT * FROM users u, logs l WHERE u.usrid=$1 AND u.usrid=l.usrid
AND l.date = $2;
EXECUTE usrrptplan(1, current_date);
```

---

SQL 标准兼容性
----------

SQL 标准包括一个 `PREPARE` 语句，但它只能在嵌入式 SQL 中使用，并且它使用了不同的语法。

